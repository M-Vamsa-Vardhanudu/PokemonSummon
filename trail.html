<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Battle Simulator</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="card-tilt.css">

    <style>
        
        body {
            background-color: #0d1117;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }

        .battle-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            animation: pulse-glow 2s infinite alternate;
        }
        @keyframes pulse-glow {
            from { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff; }
            to { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff; }
        }

        /* Battle Arena Layout */
        .battle-arena {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 40px;
            position: relative;
        }
        .battle-arena::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, #0d1117, #5a68d4, #0d1117);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #5a68d4;
            z-index: -1;
        }
        
        .pokemon-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            box-shadow: 0 0 20px rgba(90, 104, 212, 0.2);
            transition: all 0.3s ease-in-out;
        }
        .pokemon-area:hover {
            transform: scale(1.03);
            box-shadow: 0 0 30px rgba(90, 104, 212, 0.4);
        }

        .pokemon-details h3 {
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        
        .pokemon-image {
            width: 150px;
            height: 150px;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
            animation: sprite-float 3s infinite ease-in-out;
        }
        .pokemon-area.opponent .pokemon-image {
             transform: scaleX(-1);
        }
        @keyframes sprite-float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* Health Bar */
        .hp-bar-container {
            width: 90%;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #3498db);
            transition: width 0.5s ease-in-out;
        }
        .hp-fill.low { background: linear-gradient(90deg, #c0392b, #e74c3c); }
        .hp-fill.mid { background: linear-gradient(90deg, #f1c40f, #f39c12); }
        
        /* Move Buttons */
        .move-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 40px;
        }
        .move-btn {
            background: linear-gradient(45deg, #5a68d4, #9b59b6);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            text-transform: capitalize;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
            transition: all 0.3s ease-in-out;
            position: relative;
            overflow: hidden;
        }
        .move-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.7);
        }
        .move-btn:disabled {
            background: #2c3e50;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Battle Log */
        .battle-log {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            max-height: 250px;
            overflow-y: auto;
            text-align: left;
            margin-top: 40px;
            box-shadow: 0 0 20px rgba(90, 104, 212, 0.2);
        }
        .battle-log p {
            margin: 5px 0;
            font-size: 14px;
            color: #e0e0e0;
        }
        .player-text { color: #00ffff; }
        .opponent-text { color: #ff69b4; }

        /* Other UI elements (Raid sections, etc.) */
        .raid-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(90, 104, 212, 0.2);
            text-align: center;
        }
        .raid-section h2 { color: #00ffff; }

        .btn.raid-btn {
            background: linear-gradient(45deg, #9b59b6, #5a68d4);
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
            padding: 12px 24px;
        }
        .btn.raid-btn:hover {
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.7);
        }

        /* Media Queries for Mobile */
        @media (max-width: 768px) {
            .battle-arena {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .move-buttons {
                grid-template-columns: 1fr;
            }
            .raid-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pokémon Battle Simulator</h1>

        <div id="startScreen" class="card">
            <p>Click the button below to start a random Pokémon battle!</p>
            <button class="start-btn btn" id="startBattle">Start Battle</button>
            <div id="loader" class="loader hidden"></div>
        </div>
        
        <div id="battleScreen" class="battle-screen hidden">
            <div class="battle-arena">
                <div class="pokemon-area player">
                    <h2>Your Pokémon</h2>
                    <div class="pokemon-details">
                        <h3 id="playerName">Player</h3>
                        <div class="type-container" id="playerTypes"></div>
                        <img id="playerImage" class="pokemon-image" src="" alt="Player Pokémon">
                        <div class="hp-info">
                            <span id="playerCurrentHP">100</span>/<span id="playerMaxHP">100</span> HP
                        </div>
                        <div class="hp-bar-container">
                            <div class="hp-fill" id="playerHPFill"></div>
                        </div>
                    </div>
                </div>
                
                <div class="pokemon-area opponent">
                    <h2>Opponent</h2>
                    <div class="pokemon-details">
                        <h3 id="opponentName">Opponent</h3>
                        <div class="type-container" id="opponentTypes"></div>
                        <img id="opponentImage" class="pokemon-image" src="" alt="Opponent Pokémon">
                        <div class="hp-info">
                            <span id="opponentCurrentHP">100</span>/<span id="opponentMaxHP">100</span> HP
                        </div>
                        <div class="hp-bar-container">
                            <div class="hp-fill" id="opponentHPFill"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="battle-controls">
                <div class="move-buttons" id="moveButtons"></div>
                <div id="teamSwitchBar" class="team-switch-bar hidden"></div>
                <button class="restart-btn btn hidden" id="restartBattle">Battle Again</button>
            </div>
            
            <div id="battleLog" class="battle-log-card">
                </div>
            
            <div id="raidCapturePanel" class="raid-capture-panel card hidden">
                <h3>Raid Victory! Capture Opportunity</h3>
                <p id="raidCaptureIntro"></p>
                <div class="capture-balls" id="raidCaptureButtons"></div>
                <div id="raidCaptureResult"></div>
            </div>
        </div>
    </div>
    
    <script>
       
        // DOM Elements
        const startScreen = document.getElementById('startScreen');
        const battleScreen = document.getElementById('battleScreen');
        const startBattleBtn = document.getElementById('startBattle');
        const restartBattleBtn = document.getElementById('restartBattle');
        const loader = document.getElementById('loader');
        const battleLog = document.getElementById('battleLog');
        const moveButtons = document.getElementById('moveButtons');
        
        // Player Pokémon elements
        const playerName = document.getElementById('playerName');
        const playerImage = document.getElementById('playerImage');
        const playerTypes = document.getElementById('playerTypes');
        const playerCurrentHP = document.getElementById('playerCurrentHP');
        const playerMaxHP = document.getElementById('playerMaxHP');
        const playerHPFill = document.getElementById('playerHPFill');
        
        // Opponent Pokémon elements
        const opponentName = document.getElementById('opponentName');
        const opponentImage = document.getElementById('opponentImage');
        const opponentTypes = document.getElementById('opponentTypes');
        const opponentCurrentHP = document.getElementById('opponentCurrentHP');
        const opponentMaxHP = document.getElementById('opponentMaxHP');
        const opponentHPFill = document.getElementById('opponentHPFill');
        
        // Battle state
        let playerPokemon = null;
        let opponentPokemon = null;
        let currentTurn = 'player';
        let battleEnded = false;
        let playerProtected = false;
        let opponentProtected = false;
        
        // Constants
        const MAX_POKEMON_ID = 151; // Limit to Gen 1 for simplicity
        const MAX_MOVES = 4;
        
        // --- Raid system additions ---
        const RAID_COOLDOWN_MINUTES = 10;
        const RAID_ENTRY_FEE = 500; // coins
        let isRaid = false;
        let raidTeam = [];      // Array of battle-ready Pokémon objects (player side)
        let activePlayerIndex = 0;
        let raidBossOriginal = null;
        let raidCooldownUntil = null;
        let raidCapturePhase = false;
        let userCoins = 0;
        let selectedBossData = null;
        let availableBosses = [];
        
        const raidSection = document.getElementById('raidSection');
        const openRaidLobbyBtn = document.getElementById('openRaidLobbyBtn');
        const raidLobby = document.getElementById('raidLobby');
        const teamSelectGrid = document.getElementById('teamSelectGrid');
        const proceedToPaymentBtn = document.getElementById('proceedToPaymentBtn');
        const raidTeamMeta = document.getElementById('raidTeamMeta');
        const teamSwitchBar = document.getElementById('teamSwitchBar');
        const raidCooldownMsg = document.getElementById('raidCooldownMsg');
        const raidCapturePanel = document.getElementById('raidCapturePanel');
        const raidCaptureButtons = document.getElementById('raidCaptureButtons');
        const raidCaptureIntro = document.getElementById('raidCaptureIntro');
        const raidCaptureResult = document.getElementById('raidCaptureResult');
        
        // New elements for payment and boss selection
        const paymentPanel = document.getElementById('paymentPanel');
        const userCoinsDisplay = document.getElementById('userCoinsDisplay');
        const payEntryFeeBtn = document.getElementById('payEntryFeeBtn');
        const cancelPaymentBtn = document.getElementById('cancelPaymentBtn');
        const bossSelectionPanel = document.getElementById('bossSelectionPanel');
        const bossOptions = document.getElementById('bossOptions');
        const confirmBossBtn = document.getElementById('confirmBossBtn');
        const cancelBossBtn = document.getElementById('cancelBossBtn');
        const confirmSelectionPanel = document.getElementById('confirmSelectionPanel');
        const selectedBossInfo = document.getElementById('selectedBossInfo');
        const startRaidBattleBtn = document.getElementById('startRaidBattleBtn');
        const backToBossBtn = document.getElementById('backToBossBtn');
        
        // Legendary & Mythical pools (subset for brevity – extend as needed)
        const LEGENDARIES = [144,145,146,150,243,244,245,249,250,382,383,384,483,484,485,486,488,716,717,718];
        const MYTHICALS = [151,251,385,386,489,490,491,492,493,494,647,648,649];
        
        // Reduced raid capture multipliers (applied over simplified base)
        const RAID_CAPTURE_MOD = 0.5; // 50% of normal catch odds
        
        // Start battle when button is clicked
        startBattleBtn.addEventListener('click', startBattle);
        restartBattleBtn.addEventListener('click', restartBattle);
        openRaidLobbyBtn.addEventListener('click', toggleRaidLobby);
        
        // New raid flow event listeners
        proceedToPaymentBtn.addEventListener('click', proceedToPayment);
        payEntryFeeBtn.addEventListener('click', payEntryFee);
        cancelPaymentBtn.addEventListener('click', cancelPayment);
        confirmBossBtn.addEventListener('click', confirmBossSelection);
        cancelBossBtn.addEventListener('click', cancelBossSelection);
        startRaidBattleBtn.addEventListener('click', startRaidBattle);
        backToBossBtn.addEventListener('click', backToBossSelection);
        
        // Start a new battle
        async function startBattle() {
            try {
                // Show loader, hide start button
                startBattleBtn.classList.add('hidden');
                loader.classList.remove('hidden');
                
                // Generate random IDs for player and opponent Pokémon
                const playerPokemonId = Math.floor(Math.random() * MAX_POKEMON_ID) + 1;
                let opponentPokemonId;
                do {
                    opponentPokemonId = Math.floor(Math.random() * MAX_POKEMON_ID) + 1;
                } while (opponentPokemonId === playerPokemonId);
                
                // Fetch Pokémon data in parallel
                const [playerData, opponentData] = await Promise.all([
                    fetchPokemonData(playerPokemonId),
                    fetchPokemonData(opponentPokemonId)
                ]);
                
                // Set up player and opponent Pokémon
                playerPokemon = createBattlePokemon(playerData);
                opponentPokemon = createBattlePokemon(opponentData);
                
                // Update UI with Pokémon data (moves will be resolved inside)
                await updatePokemonUI();
                
                // Hide start screen, show battle screen
                startScreen.classList.add('hidden');
                battleScreen.classList.remove('hidden');
                
                // Add initial battle message
                addBattleMessage(`A wild ${capitalizeFirstLetter(opponentPokemon.name)} appeared!`);
                addBattleMessage(`Go, ${capitalizeFirstLetter(playerPokemon.name)}!`);
                addBattleMessage(`What will ${capitalizeFirstLetter(playerPokemon.name)} do?`);
                
            } catch (error) {
                console.error('Error starting battle:', error);
                addBattleMessage('Error starting battle. Please try again.');
                loader.classList.add('hidden');
                startBattleBtn.classList.remove('hidden');
            }
        }
        
        // Restart the battle
        function restartBattle() {
            // Reset UI
            battleLog.innerHTML = '';
            moveButtons.innerHTML = '';
            restartBattleBtn.classList.add('hidden');
            
            // Show start screen, hide battle screen
            battleScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            startBattleBtn.classList.remove('hidden');
            
            // Reset battle state
            playerPokemon = null;
            opponentPokemon = null;
            currentTurn = 'player';
            battleEnded = false;
            
        }
        
        // Fetch Pokémon data from the API
        async function fetchPokemonData(id) {
            const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
            return await response.json();
        }
        
        // Create a battle-ready Pokémon object from API data
        function createBattlePokemon(data) {
            // Calculate HP based on base stat
            const baseHP = data.stats.find(stat => stat.stat.name === 'hp').base_stat;
            const maxHP = Math.floor(baseHP * 2); // Simplified HP calculation
            
            // Get random moves (up to 4)
            const allMoves = data.moves.map(moveData => moveData.move);
            const selectedMoves = getRandomItems(allMoves, Math.min(MAX_MOVES, allMoves.length));
            
            // Fetch move details for each selected move
            const movePromises = selectedMoves.map(move => fetchMoveData(move.url));
            
            return {
                id: data.id,
                name: data.name,
                types: data.types.map(typeData => typeData.type.name),
                maxHP: maxHP,
                currentHP: maxHP,
                moves: movePromises,
                sprite: data.sprites.front_default,
                attack: data.stats.find(stat => stat.stat.name === 'attack').base_stat,
                defense: data.stats.find(stat => stat.stat.name === 'defense').base_stat,
                specialAttack: data.stats.find(stat => stat.stat.name === 'special-attack').base_stat,
                specialDefense: data.stats.find(stat => stat.stat.name === 'special-defense').base_stat,
                speed: data.stats.find(stat => stat.stat.name === 'speed').base_stat
            };
        }
        
        // Fetch move data from the API
        async function fetchMoveData(url) {
            const response = await fetch(url);
            const data = await response.json();
            
            return {
                id: data.id,
                name: data.name,
                type: data.type.name,
                power: data.power || 40, // Default power if not specified
                accuracy: data.accuracy || 100, // Default accuracy if not specified
                damageClass: data.damage_class?.name || 'physical',
                pp: data.pp || 10
            };
        }
        
        // Update UI with Pokémon data
        async function updatePokemonUI() {
            // Update player Pokémon UI
            playerName.textContent = capitalizeFirstLetter(playerPokemon.name);
            playerImage.src = playerPokemon.sprite;
            playerImage.alt = playerPokemon.name;
            playerCurrentHP.textContent = playerPokemon.currentHP;
            playerMaxHP.textContent = playerPokemon.maxHP;
            playerHPFill.style.width = `${(playerPokemon.currentHP / playerPokemon.maxHP) * 100}%`;
            
            // Update player types
            playerTypes.innerHTML = '';
            playerPokemon.types.forEach(type => {
                const typeElement = document.createElement('span');
                typeElement.classList.add('type-badge', type);
                typeElement.textContent = type;
                playerTypes.appendChild(typeElement);
            });
            
            // Update opponent Pokémon UI
            opponentName.textContent = capitalizeFirstLetter(opponentPokemon.name);
            opponentImage.src = opponentPokemon.sprite;
            opponentImage.alt = opponentPokemon.name;
            opponentCurrentHP.textContent = opponentPokemon.currentHP;
            opponentMaxHP.textContent = opponentPokemon.maxHP;
            opponentHPFill.style.width = `${(opponentPokemon.currentHP / opponentPokemon.maxHP) * 100}%`;
            
            // Update opponent types
            opponentTypes.innerHTML = '';
            opponentPokemon.types.forEach(type => {
                const typeElement = document.createElement('span');
                typeElement.classList.add('type-badge', type);
                typeElement.textContent = type;
                opponentTypes.appendChild(typeElement);
            });
            
            // Resolve move promises
            playerPokemon.moves = await Promise.all(playerPokemon.moves);
            opponentPokemon.moves = await Promise.all(opponentPokemon.moves);
            
            // Create move buttons after moves are resolved
            createMoveButtons();
        }
        
        // Create move buttons for player Pokémon
        function createMoveButtons() {
            moveButtons.innerHTML = '';
            
            // Create a button for each move
            playerPokemon.moves.forEach((move, index) => {
                const button = document.createElement('button');
                button.classList.add('move-btn', move.type);
                button.textContent = `${capitalizeFirstLetter(move.name)} (${move.power || '—'})`;
                button.dataset.moveIndex = index;
                button.addEventListener('click', () => useMove(index));
                moveButtons.appendChild(button);
            });
        }
        
        // Use a move
        async function useMove(moveIndex) {
            if (battleEnded) return;
        
            disableMoveButtons(true);
        
            if (currentTurn === 'player') {
                const move = playerPokemon.moves[moveIndex];
                addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} used ${capitalizeFirstLetter(move.name)}!`, 'player-text');
        
                // Check for "protect" move
                if (move.name.toLowerCase().includes('protect')) {
                    playerProtected = true;
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} is protected this turn!`);
                }
                // Check for stat-altering moves
                else if (isStatMove(move.name)) {
                    applyStatMove(playerPokemon, move, 'player');
                }
                // Damage-dealing moves
                else if (move.power && move.power > 0) {
                    const damage = calculateDamage(playerPokemon, opponentPokemon, move);
                    await applyDamage(opponentPokemon, damage, opponentCurrentHP, opponentHPFill);
                    playerProtected = false;
                } else {
                    addBattleMessage(`But nothing happened!`);
                    playerProtected = false;
                }
        
                if (opponentPokemon.currentHP <= 0) {
                    addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} fainted!`);
                    endBattle(true);
                    return;
                }
        
                currentTurn = 'opponent';
                setTimeout(opponentTurn, 1500);
            }
        }
        
        // Opponent's turn
        async function opponentTurn() {
            if (battleEnded) return;
            
            const moveIndex = Math.floor(Math.random() * opponentPokemon.moves.length);
            const move = opponentPokemon.moves[moveIndex];
        
            addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} used ${capitalizeFirstLetter(move.name)}!`, 'opponent-text');
        
            if (move.name.toLowerCase().includes('protect')) {
                opponentProtected = true;
                addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} is protected this turn!`);
            }
            else if (isStatMove(move.name)) {
                applyStatMove(opponentPokemon, move, 'opponent');
            }
            else if (move.power && move.power > 0) {
                if (playerProtected) {
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} protected itself! No damage taken.`);
                    playerProtected = false;
                } else {
                    const damage = calculateDamage(opponentPokemon, playerPokemon, move);
                    await applyDamage(playerPokemon, damage, playerCurrentHP, playerHPFill);
                }
                opponentProtected = false;
            } else {
                addBattleMessage(`But nothing happened!`);
                opponentProtected = false;
            }
        
            if (playerPokemon.currentHP <= 0) {
                addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} fainted!`);
                endBattle(false);
                return;
            }
        
            currentTurn = 'player';
            disableMoveButtons(false);
            addBattleMessage(`What will ${capitalizeFirstLetter(playerPokemon.name)} do?`);
        }
        
        // Detect stat-altering moves by name (add more as needed)
        function isStatMove(moveName) {
            const statMoves = [
                'calm mind', 'swords dance', 'growl', 'leer', 'tail whip', 'harden', 'agility', 'iron defense',
                'bulk up', 'double team', 'amnesia', 'minimize', 'defense curl', 'focus energy', 'howl', 'work up'
            ];
            return statMoves.some(statMove => moveName.toLowerCase().includes(statMove));
        }
        
        // Apply stat changes for stat-altering moves
        function applyStatMove(pokemon, move, side) {
            const name = capitalizeFirstLetter(pokemon.name);
            const moveName = move.name.toLowerCase();
        
            if (moveName.includes('calm mind')) {
                pokemon.specialAttack = Math.floor(pokemon.specialAttack * 1.5);
                pokemon.specialDefense = Math.floor(pokemon.specialDefense * 1.5);
                addBattleMessage(`${name}'s Special Attack and Special Defense rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('swords dance')) {
                pokemon.attack = Math.floor(pokemon.attack * 2);
                addBattleMessage(`${name}'s Attack sharply rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('growl')) {
                if (side === 'player') {
                    opponentPokemon.attack = Math.max(1, Math.floor(opponentPokemon.attack * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)}'s Attack fell!`, 'opponent-text');
                } else {
                    playerPokemon.attack = Math.max(1, Math.floor(playerPokemon.attack * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)}'s Attack fell!`, 'player-text');
                }
            } else if (moveName.includes('leer') || moveName.includes('tail whip')) {
                if (side === 'player') {
                    opponentPokemon.defense = Math.max(1, Math.floor(opponentPokemon.defense * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)}'s Defense fell!`, 'opponent-text');
                } else {
                    playerPokemon.defense = Math.max(1, Math.floor(playerPokemon.defense * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)}'s Defense fell!`, 'player-text');
                }
            } else if (moveName.includes('harden') || moveName.includes('iron defense') || moveName.includes('defense curl')) {
                pokemon.defense = Math.floor(pokemon.defense * 1.5);
                addBattleMessage(`${name}'s Defense rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('agility') || moveName.includes('double team')) {
                pokemon.speed = Math.floor(pokemon.speed * 1.5);
                addBattleMessage(`${name}'s Speed rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('amnesia')) {
                pokemon.specialDefense = Math.floor(pokemon.specialDefense * 2);
                addBattleMessage(`${name}'s Special Defense sharply rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('focus energy') || moveName.includes('howl') || moveName.includes('work up')) {
                pokemon.attack = Math.floor(pokemon.attack * 1.5);
                addBattleMessage(`${name}'s Attack rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('minimize')) {
                pokemon.speed = Math.floor(pokemon.speed * 2);
                addBattleMessage(`${name}'s evasiveness rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else {
                addBattleMessage(`But nothing happened!`, side === 'player' ? 'player-text' : 'opponent-text');
            }
        }
        
        // Calculate damage
        function calculateDamage(attacker, defender, move) {
            // Skip calculation if move has no power
            if (!move.power) return 0;
        
            // Use fixed level for both Pokémon
            const level = 50;
        
            // Choose attack/defense stats based on move class
            let attack = move.damageClass === 'special' ? attacker.specialAttack : attacker.attack;
            let defense = move.damageClass === 'special' ? defender.specialDefense : defender.defense;
        
            // STAB (Same Type Attack Bonus)
            let stab = attacker.types.includes(move.type) ? 1.5 : 1.0;
        
            // Type effectiveness
            const effectiveness = getTypeEffectiveness(move.type, defender.types);
        
            // Random factor between 0.85 and 1.00
            const random = (Math.random() * 0.15) + 0.85;
        
            // Accuracy check
            if (move.accuracy && Math.random() * 100 > move.accuracy) {
                addBattleMessage('But it missed!');
                return 0;
            }
        
            // Damage formula (classic Pokémon)
            let baseDamage = (((2 * level / 5 + 2) * move.power * attack / defense) / 50) + 2;
            let modifier = stab * effectiveness * random;
            let damage = Math.floor(baseDamage * modifier);
        
            // Critical hit (10% chance)
            if (Math.random() < 0.1) {
                damage = Math.floor(damage * 1.5);
                addBattleMessage('A critical hit!');
            }
        
            // Type effectiveness messages
            if (effectiveness > 1) {
                addBattleMessage('It\'s super effective!');
            } else if (effectiveness < 1 && effectiveness > 0) {
                addBattleMessage('It\'s not very effective...');
            } else if (effectiveness === 0) {
                addBattleMessage('It has no effect...');
                return 0;
            }
        
            // Ensure minimum damage is 1 if move hit and effectiveness > 0
            return Math.max(1, damage);
        }
        
        // Apply damage to a Pokémon
        async function applyDamage(pokemon, damage, hpElement, hpFillElement) {
            pokemon.currentHP = Math.max(0, pokemon.currentHP - damage);
            hpElement.textContent = pokemon.currentHP;
            hpFillElement.style.width = `${(pokemon.currentHP / pokemon.maxHP) * 100}%`;
            
            // Update HP bar color based on remaining HP percentage
            const hpPercentage = pokemon.currentHP / pokemon.maxHP;
            if (hpPercentage <= 0.2) {
                hpFillElement.style.backgroundColor = '#ff0000'; // Red
            } else if (hpPercentage <= 0.5) {
                hpFillElement.style.backgroundColor = '#ffff00'; // Yellow
            } else {
                hpFillElement.style.backgroundColor = '#4CAF50'; // Green
            }
            
            return new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // End the battle
        function endBattle(playerWon) {
            battleEnded = true;
            
            if (playerWon) {
                addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} won the battle!`);
            } else {
                addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} won the battle!`);
            }
            
            // Show restart button
            restartBattleBtn.classList.remove('hidden');
        }
        
        // Add a message to the battle log
        function addBattleMessage(message, className) {
            const messageElement = document.createElement('p');
            messageElement.textContent = message;
            if (className) {
                messageElement.classList.add(className);
            }
            battleLog.appendChild(messageElement);
            battleLog.scrollTop = battleLog.scrollHeight;
        }
        
        // Enable/disable move buttons
        function disableMoveButtons(disabled) {
            const buttons = moveButtons.querySelectorAll('button');
            buttons.forEach(button => {
                button.disabled = disabled;
            });
        }
        
        // Get random items from an array
        function getRandomItems(array, count) {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }
        
        // Capitalize the first letter of a string
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.replace('-', ' ').slice(1);
        }
        
        // Get type effectiveness (simplified version)
        function getTypeEffectiveness(moveType, defenderTypes) {
            // Simplified type chart for demo purposes
            const typeChart = {
                normal: { rock: 0.5, ghost: 0, steel: 0.5 },
                fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
                water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 },
                electric: { water: 2, electric: 0.5, grass: 0.5, ground: 0, flying: 2, dragon: 0.5 },
                grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },
                ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
                fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2, fairy: 0.5 },
                poison: { grass: 2, poison: 0.5, ground: 0.5, rock: 0.5, ghost: 0.5, steel: 0, fairy: 2 },
                ground: { fire: 2, electric: 2, grass: 0.5, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 },
                flying: { electric: 0.5, grass: 2, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
                psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 },
                bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5, fairy: 0.5 },
                rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 },
                ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5 },
                dragon: { dragon: 2, steel: 0.5, fairy: 0 },
                dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5 },
                steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5, fairy: 2 },
                fairy: { fighting: 2, poison: 0.5, bug: 0.5, dragon: 2, dark: 2, steel: 0.5 }
            };
            
            let effectiveness = 1;
            
            defenderTypes.forEach(defenderType => {
                if (typeChart[moveType] && typeChart[moveType][defenderType] !== undefined) {
                    effectiveness *= typeChart[moveType][defenderType];
                }
            });
            
            return effectiveness;
        }
        
        /* Raid functions */
        function toggleRaidLobby(){
            if(!checkRaidCooldownUI()) return;
            raidLobby.classList.toggle('hidden');
            if(!raidLobby.classList.contains('hidden')) {
                loadOwnedPokemonForRaid();
            }
        }
        
        async function loadSavedRaidTeamIds(){
            try{
                const r = await fetch('/api/raid-team');
                if(!r.ok) return [];
                const d = await r.json();
                return Array.isArray(d.team) ? d.team : [];
            }catch{ return []; }
        }
        async function saveRaidTeamIds(ids){
            try{
                await fetch('/api/raid-team',{
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({ team:ids })
                });
            }catch{}
        }
        
        async function loadOwnedPokemonForRaid() {
            teamSelectGrid.innerHTML = 'Loading...';
            try {
                const savedIds = await loadSavedRaidTeamIds(); // NEW
                const res = await fetch('/api/get-pokemon');
                const data = await res.json();
                teamSelectGrid.innerHTML = '';
                const selectedIds = new Set(savedIds.slice(0,3)); // pre-select (max 3)
                data.forEach(p => {
                    const card = document.createElement('div');
                    card.className = 'team-card';
                    const id = p.pokemonId || p.id;
                    const name = p.pokemonName || p.name;
                    const img = p.pokemonImage || p.image || `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
                    card.innerHTML = `<img src="${img}" alt="${name}"><div style="font-size:12px;text-align:center">${capitalizeFirstLetter(name)}<br>#${String(id).padStart(3,'0')}</div>`;
                    if (selectedIds.has(id)) card.classList.add('selected'); // NEW
                    card.addEventListener('click', () => {
                        if (card.classList.contains('selected')) {
                            card.classList.remove('selected');
                            selectedIds.delete(id);
                        } else {
                            if (selectedIds.size >= 3) return;
                            card.classList.add('selected');
                            selectedIds.add(id);
                        }
                        updateRaidTeamMeta(selectedIds);
                    });
                    teamSelectGrid.appendChild(card);
                });
                updateRaidTeamMeta(selectedIds); // NEW ensure button state
            } catch (e) {
                teamSelectGrid.innerHTML = 'Failed to load Pokémon.';
            }
        }
        
        function updateRaidTeamMeta(selectedIds){
            raidTeamMeta.textContent = `Selected: ${[...selectedIds].join(', ') || 'None'}`;
            startRaidBtn.disabled = selectedIds.size === 0;
        }
        
        function checkRaidCooldownUI() {
            const now = Date.now();
            const stored = localStorage.getItem('raidCooldownUntil');
            if (stored) {
                const ts = parseInt(stored,10);
                if (ts > now) {
                    const mins = Math.ceil((ts - now)/60000);
                    raidCooldownMsg.textContent = `Raid on cooldown. Try again in ~${mins} min.`;
                    raidCooldownMsg.classList.remove('hidden');
                    return false;
                }
            }
            raidCooldownMsg.classList.add('hidden');
            return true;
        }
        
        function setRaidCooldown() {
            const until = Date.now() + RAID_COOLDOWN_MINUTES * 60000;
            localStorage.setItem('raidCooldownUntil', until);
        }
        
        async function startRaid(){
            if (!checkRaidCooldownUI()) return;
            const selected = [...teamSelectGrid.querySelectorAll('.team-card.selected')];
            if (!selected.length) return;
            const pickedIds = [];
            raidTeam = [];
            for (const card of selected) {
                const idText = card.querySelector('div').textContent.match(/#(\d+)/);
                if (!idText) continue;
                const id = parseInt(idText[1],10);
                pickedIds.push(id);                 // NEW
                const raw = await fetchPokemonData(id);
                raidTeam.push(createBattlePokemon(raw));
            }
            await saveRaidTeamIds(pickedIds);       // NEW persist team
            // Determine raid boss (legendary or mythical)
            const pool = Math.random() < 0.5 ? LEGENDARIES : MYTHICALS;
            const bossId = pool[Math.floor(Math.random()*pool.length)];
            isRaid = true;
            raidCapturePhase = false;
            await prepareRaidBoss(bossId);
            raidLobby.classList.add('hidden');
            startBattleCore(true); // start using raid data
        }
        
        async function prepareRaidBoss(id){
            const data = await fetchPokemonData(id);
            opponentPokemon = createBattlePokemon(data);
            raidBossOriginal = opponentPokemon.name;
            // Boost boss stats for challenge
            opponentPokemon.maxHP = Math.floor(opponentPokemon.maxHP * 1.3);
            opponentPokemon.currentHP = opponentPokemon.maxHP;
            opponentPokemon.defense = Math.floor(opponentPokemon.defense * 1.15);
            opponentPokemon.specialDefense = Math.floor(opponentPokemon.specialDefense * 1.15);
        }
        
        function startBattleCore(raidMode=false){
            // For raid: playerPokemon = active member of raidTeam
            if (raidMode && raidTeam.length){
                activePlayerIndex = 0;
                playerPokemon = raidTeam[activePlayerIndex];
            }
            // Reuse existing update flow
            startScreen.classList.add('hidden');
            battleScreen.classList.remove('hidden');
            loader.classList.add('hidden');
            buildTeamSwitchBar();
            updatePokemonUI().then(()=>{
                if (isRaid){
                    addBattleMessage(`A Raid Boss ${capitalizeFirstLetter(opponentPokemon.name)} appeared!`, 'opponent-text');
                    addBattleMessage(`Send out ${capitalizeFirstLetter(playerPokemon.name)}!`, 'player-text');
                }
            });
        }
        
        function buildTeamSwitchBar(){
            if (!isRaid) return;
            if (!teamSwitchBar) return; // NEW null guard
            teamSwitchBar.innerHTML = '';
            teamSwitchBar.classList.remove('hidden');
            raidTeam.forEach((p, idx)=>{
                const btn = document.createElement('button');
                btn.className='team-switch-btn';
                btn.textContent = capitalizeFirstLetter(p.name);
                btn.disabled = (idx === activePlayerIndex) || p.currentHP<=0;
                if (idx === activePlayerIndex) btn.classList.add('active');
                btn.addEventListener('click', ()=> switchActivePokemon(idx));
                teamSwitchBar.appendChild(btn);
            });
        }
        
        async function ensureMovesLoaded(pokemon){ // NEW
            if (!pokemon) return;
            if (Array.isArray(pokemon.moves) && pokemon.moves.length && typeof pokemon.moves[0].then === 'function'){
                pokemon.moves = await Promise.all(pokemon.moves);
            }
        }
        
        function switchActivePokemon(newIndex){
            if (battleEnded || raidCapturePhase) return;
            if (newIndex === activePlayerIndex) return;
            if (raidTeam[newIndex].currentHP<=0) return;
            activePlayerIndex = newIndex;
            playerPokemon = raidTeam[activePlayerIndex];
            ensureMovesLoaded(playerPokemon).then(()=>{
                createMoveButtons(); // NEW regenerate buttons for new mon
                addBattleMessage(`You switched to ${capitalizeFirstLetter(playerPokemon.name)}!`, 'player-text');
                updatePokemonUI();
                disableMoveButtons(false);
                buildTeamSwitchBar();
            });
        }
        
        // Override faint handling in existing flow: hook into applyDamage aftermath via checks where faint is processed
        const originalEndBattle = endBattle;
        endBattle = function(playerWon){
            if (isRaid && playerWon){
                // Instead of immediate end -> capture phase
                raidCapturePhase = true;
                disableMoveButtons(true);
                addBattleMessage('Raid Boss defeated! Capture opportunity begins.', 'player-text');
                showRaidCaptureUI();
                setRaidCooldown();
                return;
            }
            originalEndBattle(playerWon);
            if (isRaid && !playerWon) setRaidCooldown();
        };
        
        // Inject check after opponent damages player (loss condition across team)
        const originalOpponentTurn = opponentTurn;
        opponentTurn = async function(){
            await originalOpponentTurn();
            if (isRaid && !battleEnded && playerPokemon?.currentHP===0){
                // Try auto-switch
                const nextIdx = raidTeam.findIndex(p=>p.currentHP>0);
                if (nextIdx===-1){
                    addBattleMessage('All your team fainted!', 'opponent-text');
                    originalEndBattle(false);
                    setRaidCooldown();
                } else {
                    activePlayerIndex = nextIdx;
                    playerPokemon = raidTeam[activePlayerIndex];
                    await ensureMovesLoaded(playerPokemon); // NEW
                    createMoveButtons();                    // NEW
                    buildTeamSwitchBar();
                    addBattleMessage(`Go, ${capitalizeFirstLetter(playerPokemon.name)}!`, 'player-text');
                    updatePokemonUI();
                    disableMoveButtons(false);
                    buildTeamSwitchBar();
                }
            }
            buildTeamSwitchBar();
        };
        
        // Replace startBattle entry for random (kept) to call startBattleCore(false). We minimally wrap original startBattle.
        const originalStartBattle = startBattle;
        startBattle = async function(){
            isRaid = false;
            raidTeam = [];
            await originalStartBattle();
        };
        
        // --- Raid Capture Phase ---
        async function showRaidCaptureUI(){
            raidCapturePanel.classList.remove('hidden');
            raidCaptureIntro.textContent = `You have a limited chance to capture ${capitalizeFirstLetter(raidBossOriginal)}. Choose a Poké Ball:`;
            raidCaptureButtons.innerHTML='Loading balls...';
            try {
                const res = await fetch('/api/pokeballs');
                const data = await res.json();
                const inventory = {};
                (data.pokeballs||[]).forEach(b=>inventory[b.type]=b.count);
                const ballTypes = ['pokeball','greatball','ultraball','masterball'];
                raidCaptureButtons.innerHTML='';
                ballTypes.forEach(bt=>{
                    const count = inventory[bt]||0;
                    const btn = document.createElement('button');
                    btn.textContent = `${formatBall(bt)} (${count})`;
                    btn.disabled = count<=0;
                    btn.addEventListener('click', ()=>attemptRaidCapture(bt,count));
                    raidCaptureButtons.appendChild(btn);
                });
            } catch (e){
                raidCaptureButtons.innerHTML='Failed to load inventory.';
            }
        }
        
        function formatBall(bt){
            switch(bt){
                case 'pokeball': return 'Poké Ball';
                case 'greatball': return 'Great Ball';
                case 'ultraball': return 'Ultra Ball';
                case 'masterball': return 'Master Ball';
                default: return bt;
            }
        }
        
        async function attemptRaidCapture(ballType,currentCount){
            // Decrement immediately (optimistic)
            await fetch('/api/pokeballs-update', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify({type:ballType,count:currentCount-1})
            }).catch(()=>{});
            
            const base = { pokeball:0.08, greatball:0.15, ultraball:0.25, masterball:1.0 }[ballType] || 0.05;
            const chance = Math.min(1, base * RAID_CAPTURE_MOD);
            const roll = Math.random();
            const success = roll < chance || ballType==='masterball';
            raidCaptureResult.textContent = `Roll ${(roll*100).toFixed(1)}% vs ${(chance*100).toFixed(1)}% => ${success? 'Captured!':'Broke free!'}`;
            if (success){
                await saveRaidCapture(opponentPokemon);
                await postRaidResult(true,true);
                addBattleMessage(`You captured ${capitalizeFirstLetter(opponentPokemon.name)}!`, 'player-text');
                finalizeRaid();
            } else {
                await postRaidResult(true,false);
                finalizeRaid();
            }
        }
        
        function finalizeRaid(){
            raidCaptureButtons.querySelectorAll('button').forEach(b=>b.disabled=true);
            restartBattleBtn.classList.remove('hidden');
            battleEnded = true;
        }
        
        async function saveRaidCapture(poke){
            try {
                await fetch('/api/save-pokemon', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({
                        pokemonName: poke.name,
                        pokemonImage: poke.sprite,
                        pokemonId: poke.id,
                        pokemonTypes: poke.types,
                        rarity: MYTHICALS.includes(poke.id)?'mythical':'legendary'
                    })
                });
            } catch(e){}
        }
        
        async function postRaidResult(defeated,captured){
            try {
                await fetch('/api/raid-result', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({
                        bossId: opponentPokemon.id,
                        defeated,
                        captured,
                        timestamp: Date.now()
                    })
                });
            } catch(e){}
        }
        
        // === NEW RAID FLOW FUNCTIONS ===
        
        // Update the team meta button text to use new flow
        function updateRaidTeamMeta(selectedIds){
            raidTeamMeta.textContent = `Selected: ${[...selectedIds].join(', ') || 'None'}`;
            startRaidBtn.disabled = selectedIds.size === 0;
        }
        
        // Step 1: Proceed to payment
        async function proceedToPayment() {
            // Hide team selection, show payment panel
            raidLobby.style.display = 'none';
            paymentPanel.style.display = 'block';
            
            // Load user coins
            await loadUserCoins();
        }
        
        // Load user's coin balance
        async function loadUserCoins() {
            try {
                const response = await fetch('/api/coins');
                const data = await response.json();
                userCoins = data.coins || 0;
                userCoinsDisplay.textContent = userCoins;
                
                // Enable/disable payment button based on coin balance
                if (userCoins >= RAID_ENTRY_FEE) {
                    payEntryFeeBtn.disabled = false;
                    payEntryFeeBtn.style.opacity = '1';
                } else {
                    payEntryFeeBtn.disabled = true;
                    payEntryFeeBtn.style.opacity = '0.5';
                }
            } catch (error) {
                console.error('Error loading coins:', error);
                userCoinsDisplay.textContent = 'Error loading coins';
                payEntryFeeBtn.disabled = true;
            }
        }
        
        // Step 2: Pay entry fee
        async function payEntryFee() {
            if (userCoins < RAID_ENTRY_FEE) {
                alert(`Not enough coins! You need ${RAID_ENTRY_FEE} coins but only have ${userCoins}.`);
                return;
            }
            
            try {
                // Deduct coins from user account
                const newBalance = userCoins - RAID_ENTRY_FEE;
                const response = await fetch('/api/update-coins', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({coins: newBalance})
                });
                
                const result = await response.json();
                if (result.success) {
                    userCoins = newBalance;
                    // Hide payment panel, show boss selection
                    paymentPanel.style.display = 'none';
                    bossSelectionPanel.style.display = 'block';
                    
                    // Generate boss options
                    await generateBossOptions();
                } else {
                    alert('Failed to process payment: ' + result.message);
                }
            } catch (error) {
                console.error('Error processing payment:', error);
                alert('Error processing payment. Please try again.');
            }
        }
        
        // Step 3: Generate 3 random boss options
        async function generateBossOptions() {
            bossOptions.innerHTML = '<p>Generating boss options...</p>';
            
            try {
                availableBosses = [];
                const allBosses = [...LEGENDARIES, ...MYTHICALS];
                const selectedBossIds = getRandomItems(allBosses, 3);
                
                // Fetch boss data
                for (const bossId of selectedBossIds) {
                    const bossData = await fetchPokemonData(bossId);
                    const rarity = MYTHICALS.includes(bossId) ? 'mythical' : 'legendary';
                    availableBosses.push({ ...bossData, rarity });
                }
                
                // Create boss cards
                bossOptions.innerHTML = '';
                availableBosses.forEach((boss, index) => {
                    const bossCard = document.createElement('div');
                    bossCard.className = 'boss-card';
                    bossCard.dataset.index = index;
                    
                    const typesHtml = boss.types.map(typeData => 
                        `<span class="type-badge ${typeData.type.name}">${typeData.type.name}</span>`
                    ).join(' ');
                    
                    bossCard.innerHTML = `
                        <img src="${boss.sprites.front_default}" alt="${boss.name}">
                        <h4>${capitalizeFirstLetter(boss.name)}</h4>
                        <div class="boss-type">${typesHtml}</div>
                        <div class="boss-rarity ${boss.rarity}">${boss.rarity.toUpperCase()}</div>
                    `;
                    
                    bossCard.addEventListener('click', () => selectBoss(index));
                    bossOptions.appendChild(bossCard);
                });
            } catch (error) {
                console.error('Error generating boss options:', error);
                bossOptions.innerHTML = '<p>Error generating bosses. Please try again.</p>';
            }
        }
        
        // Step 4: Select a boss
        function selectBoss(index) {
            // Remove previous selections
            bossOptions.querySelectorAll('.boss-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Select new boss
            const selectedCard = bossOptions.querySelector(`[data-index="${index}"]`);
            selectedCard.classList.add('selected');
            
            selectedBossData = availableBosses[index];
            confirmBossBtn.disabled = false;
        }
        
        // Step 5: Confirm boss selection
        function confirmBossSelection() {
            if (!selectedBossData) return;
            
            // Hide boss selection, show confirmation
            bossSelectionPanel.style.display = 'none';
            confirmSelectionPanel.style.display = 'block';
            
            // Show selected boss info
            const typesHtml = selectedBossData.types.map(typeData => 
                `<span class="type-badge ${typeData.type.name}">${typeData.type.name}</span>`
            ).join(' ');
            
            selectedBossInfo.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <img src="${selectedBossData.sprites.front_default}" alt="${selectedBossData.name}" style="width: 120px; height: 120px;">
                </div>
                <h3>${capitalizeFirstLetter(selectedBossData.name)}</h3>
                <div style="margin: 10px 0;">${typesHtml}</div>
                <div class="boss-rarity ${selectedBossData.rarity}" style="font-size: 14px; margin-top: 10px;">${selectedBossData.rarity.toUpperCase()}</div>
            `;
        }
        
        // Step 6: Start raid battle
        async function startRaidBattle() {
            if (!selectedBossData) return;
            
            try {
                // Prepare the selected boss
                opponentPokemon = createBattlePokemon(selectedBossData);
                raidBossOriginal = opponentPokemon.name;
                
                // Boost boss stats for challenge
                opponentPokemon.maxHP = Math.floor(opponentPokemon.maxHP * 1.3);
                opponentPokemon.currentHP = opponentPokemon.maxHP;
                opponentPokemon.defense = Math.floor(opponentPokemon.defense * 1.15);
                opponentPokemon.specialDefense = Math.floor(opponentPokemon.specialDefense * 1.15);
                
                // Get selected team
                const selected = [...teamSelectGrid.querySelectorAll('.team-card.selected')];
                const pickedIds = [];
                raidTeam = [];
                
                for (const card of selected) {
                    const idText = card.querySelector('div').textContent.match(/#(\d+)/);
                    if (!idText) continue;
                    const id = parseInt(idText[1],10);
                    pickedIds.push(id);
                    const raw = await fetchPokemonData(id);
                    raidTeam.push(createBattlePokemon(raw));
                }
                
                await saveRaidTeamIds(pickedIds);
                
                // Set raid flags and start battle
                isRaid = true;
                raidCapturePhase = false;
                
                // Hide all raid panels
                hideAllRaidPanels();
                
                // Start the battle
                startBattleCore(true);
                
            } catch (error) {
                console.error('Error starting raid battle:', error);
                alert('Error starting raid battle. Please try again.');
            }
        }
        
        // Navigation functions
        function cancelPayment() {
            paymentPanel.style.display = 'none';
            raidLobby.style.display = 'block';
        }
        
        function cancelBossSelection() {
            // Refund the entry fee
            refundEntryFee();
            bossSelectionPanel.style.display = 'none';
            raidLobby.style.display = 'block';
        }
        
        function backToBossSelection() {
            confirmSelectionPanel.style.display = 'none';
            bossSelectionPanel.style.display = 'block';
            // Clear selection
            selectedBossData = null;
            confirmBossBtn.disabled = true;
            bossOptions.querySelectorAll('.boss-card').forEach(card => {
                card.classList.remove('selected');
            });
        }
        
        // Utility function to hide all raid panels
        function hideAllRaidPanels() {
            paymentPanel.style.display = 'none';
            bossSelectionPanel.style.display = 'none';
            confirmSelectionPanel.style.display = 'none';
            raidLobby.classList.add('hidden');
        }
        
        // Refund entry fee (in case of cancellation)
        async function refundEntryFee() {
            try {
                const newBalance = userCoins + RAID_ENTRY_FEE;
                const response = await fetch('/api/update-coins', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({coins: newBalance})
                });
                
                const result = await response.json();
                if (result.success) {
                    userCoins = newBalance;
                    console.log('Entry fee refunded');
                }
            } catch (error) {
                console.error('Error refunding entry fee:', error);
            }
        }
       
    
    </script>
</body>
</html>
