<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Battle Simulator</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .battle-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .battle-arena {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 20px 0;
        }
        
        .pokemon-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        
        .pokemon-details {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 200px;
        }
        
        .opponent-details {
            align-items: flex-end;
        }
        
        .pokemon-image {
            width: 150px;
            height: 150px;
            object-fit: contain;
        }
        
        .hp-bar {
            width: 100%;
            height: 15px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .hp-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.5s ease;
        }
        
        .move-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .move-btn {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .move-btn:hover {
            background-color: #2980b9;
        }
        
        .move-btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .battle-log {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 20px;
            border-radius: 5px;
            text-align: left;
            background-color: #f9f9f9;
        }
        
        .battle-log p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .player-text {
            color: #2980b9;
        }
        
        .opponent-text {
            color: #c0392b;
        }
        
        .start-btn, .restart-btn {
            padding: 12px 24px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        
        .start-btn:hover, .restart-btn:hover {
            background-color: #219955;
        }
        
        .type-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: white;
            margin-right: 5px;
            text-transform: capitalize;
        }
        
        /* Type colors */
        .normal { background-color: #A8A878; }
        .fire { background-color: #F08030; }
        .water { background-color: #6890F0; }
        .grass { background-color: #78C850; }
        .electric { background-color: #F8D030; }
        .ice { background-color: #98D8D8; }
        .fighting { background-color: #C03028; }
        .poison { background-color: #A040A0; }
        .ground { background-color: #E0C068; }
        .flying { background-color: #A890F0; }
        .psychic { background-color: #F85888; }
        .bug { background-color: #A8B820; }
        .rock { background-color: #B8A038; }
        .ghost { background-color: #705898; }
        .dragon { background-color: #7038F8; }
        .dark { background-color: #705848; }
        .steel { background-color: #B8B8D0; }
        .fairy { background-color: #EE99AC; }
        
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        /* Raid additions */
        .raid-section {
            margin-top: 25px;
            padding: 15px;
            border: 2px dashed #7038F8;
            border-radius: 12px;
            background: #fafaff;
        }
        .raid-section h2 { margin: 0 0 10px; }
        .raid-btn {
            background:#7038F8;
        }
        .raid-btn:hover { background:#5729c2; }
        .raid-lobby.hidden { display:none; }
        .raid-lobby {
            margin-top:15px;
            padding:15px;
            border:1px solid #ddd;
            background:#ffffff;
            border-radius:10px;
            max-height:260px;
            overflow:auto;
            text-align:left;
        }
        .team-select-grid {
            display:grid;
            grid-template-columns:repeat(auto-fill,minmax(140px,1fr));
            gap:10px;
        }
        .team-card {
            border:1px solid #ccc;
            border-radius:8px;
            padding:8px;
            cursor:pointer;
            position:relative;
            background:#f5f5f5;
            transition:.2s;
        }
        .team-card.selected {
            border-color:#7038F8;
            box-shadow:0 0 0 2px #7038F8 inset;
            background:#efe9ff;
        }
        .team-card img { width:72px; height:72px; display:block; margin:0 auto 5px; }
        .team-limit-hint { font-size:12px; color:#666; margin:6px 0 0; }
        .raid-meta { font-size:13px; color:#555; margin-top:6px; }
        .team-switch-bar {
            margin-top:10px;
            display:flex;
            gap:8px;
            justify-content:center;
            flex-wrap:wrap;
        }
        .team-switch-btn {
            padding:6px 10px;
            font-size:12px;
            background:#3498db;
        }
        .team-switch-btn.active { background:#1b6fa3; }
        .team-switch-btn:disabled { background:#7f8c8d; }
        .raid-boss-banner {
            animation:pulse 1.5s infinite;
            background:linear-gradient(90deg,#ffd700,#ff69b4,#ffd700);
            background-size:300% 100%;
            -webkit-background-clip:text;
            color:transparent;
            font-weight:900;
            text-transform:uppercase;
            letter-spacing:2px;
        }
        @keyframes pulse {
            0%{background-position:0% 50%}
            50%{background-position:100% 50%}
            100%{background-position:0% 50%}
        }
        .raid-capture-panel {
            margin-top:20px;
            padding:15px;
            border:2px solid #ff8c00;
            border-radius:10px;
            background:#fff6e6;
        }
        .capture-balls {
            display:flex;
            gap:10px;
            flex-wrap:wrap;
            margin:10px 0;
        }
        .capture-balls button { background:#ff8c00; flex:1; min-width:120px; }
        .capture-balls button:hover { background:#e97700; }
        .cooldown-warning { color:#c0392b; font-size:13px; margin-top:5px; }
        .badge-small {
            display:inline-block;
            padding:2px 6px;
            background:#7038F8;
            color:#fff;
            font-size:11px;
            border-radius:6px;
            margin-left:6px;
        }
    </style>
</head>
<body>
    <div class="battle-container">
        <h1>Pokémon Battle Simulator</h1>
        <div class="raid-section" id="raidSection">
            <h2>Raid Battles <span class="badge-small">Beta</span></h2>
            <p>Form a team (up to 3) and battle a Legendary/Mythical raid boss for a capture chance.</p>
            <button class="raid-btn" id="openRaidLobbyBtn">Open Raid Lobby</button>
            <div id="raidCooldownMsg" class="cooldown-warning hidden"></div>
            <div class="raid-lobby hidden" id="raidLobby">
                <strong>Select your team (max 3)</strong>
                <div class="team-limit-hint">Click cards to toggle selection. Then Start Raid.</div>
                <div id="teamSelectGrid" class="team-select-grid"></div>
                <div class="raid-meta" id="raidTeamMeta"></div>
                <button id="startRaidBtn" class="raid-btn" disabled>Start Raid</button>
            </div>
        </div>
        <div id="startScreen">
            <p>Click the button below to start a random Pokémon battle!</p>
            <button class="start-btn" id="startBattle">Start Battle</button>
            <div id="loader" class="loader hidden"></div>
        </div>
        
        <div id="battleScreen" class="hidden">
            <div class="battle-arena">
                <div class="pokemon-area">
                    <div class="pokemon-details opponent-details">
                        <h3 id="opponentName">Opponent</h3>
                        <div class="type-container" id="opponentTypes"></div>
                        <div class="hp-info">
                            <span id="opponentCurrentHP">100</span>/<span id="opponentMaxHP">100</span> HP
                        </div>
                        <div class="hp-bar">
                            <div class="hp-fill" id="opponentHPFill" style="width: 100%;"></div>
                        </div>
                    </div>
                    <img id="opponentImage" class="pokemon-image" src="" alt="Opponent Pokémon">
                </div>
                
                <div class="pokemon-area">
                    <img id="playerImage" class="pokemon-image" src="" alt="Player Pokémon">
                    <div class="pokemon-details">
                        <h3 id="playerName">Player</h3>
                        <div class="type-container" id="playerTypes"></div>
                        <div class="hp-info">
                            <span id="playerCurrentHP">100</span>/<span id="playerMaxHP">100</span> HP
                        </div>
                        <div class="hp-bar">
                            <div class="hp-fill" id="playerHPFill" style="width: 100%;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="move-buttons" id="moveButtons">
                <!-- Move buttons will be added here by JavaScript -->
            </div>
            <div id="teamSwitchBar" class="team-switch-bar hidden"></div> <!-- NEW: team switch bar (fixes null reference) -->
            
            <div class="battle-log" id="battleLog">
                <!-- Battle messages will appear here -->
            </div>
            <div id="raidCapturePanel" class="raid-capture-panel hidden">
                <h3>Raid Victory! Capture Opportunity</h3>
                <p id="raidCaptureIntro"></p>
                <div class="capture-balls" id="raidCaptureButtons"></div>
                <div id="raidCaptureResult"></div>
            </div>
            
            <button class="restart-btn hidden" id="restartBattle">Battle Again</button>
        </div>
    </div>
    
    <script>
        // DOM Elements
        const startScreen = document.getElementById('startScreen');
        const battleScreen = document.getElementById('battleScreen');
        const startBattleBtn = document.getElementById('startBattle');
        const restartBattleBtn = document.getElementById('restartBattle');
        const loader = document.getElementById('loader');
        const battleLog = document.getElementById('battleLog');
        const moveButtons = document.getElementById('moveButtons');
        
        // Player Pokémon elements
        const playerName = document.getElementById('playerName');
        const playerImage = document.getElementById('playerImage');
        const playerTypes = document.getElementById('playerTypes');
        const playerCurrentHP = document.getElementById('playerCurrentHP');
        const playerMaxHP = document.getElementById('playerMaxHP');
        const playerHPFill = document.getElementById('playerHPFill');
        
        // Opponent Pokémon elements
        const opponentName = document.getElementById('opponentName');
        const opponentImage = document.getElementById('opponentImage');
        const opponentTypes = document.getElementById('opponentTypes');
        const opponentCurrentHP = document.getElementById('opponentCurrentHP');
        const opponentMaxHP = document.getElementById('opponentMaxHP');
        const opponentHPFill = document.getElementById('opponentHPFill');
        
        // Battle state
        let playerPokemon = null;
        let opponentPokemon = null;
        let currentTurn = 'player';
        let battleEnded = false;
        let playerProtected = false;
        let opponentProtected = false;
        
        // Constants
        const MAX_POKEMON_ID = 151; // Limit to Gen 1 for simplicity
        const MAX_MOVES = 4;
        
        // --- Raid system additions ---
        const RAID_COOLDOWN_MINUTES = 10;
        let isRaid = false;
        let raidTeam = [];      // Array of battle-ready Pokémon objects (player side)
        let activePlayerIndex = 0;
        let raidBossOriginal = null;
        let raidCooldownUntil = null;
        let raidCapturePhase = false;
        const raidSection = document.getElementById('raidSection');
        const openRaidLobbyBtn = document.getElementById('openRaidLobbyBtn');
        const raidLobby = document.getElementById('raidLobby');
        const teamSelectGrid = document.getElementById('teamSelectGrid');
        const startRaidBtn = document.getElementById('startRaidBtn');
        const raidTeamMeta = document.getElementById('raidTeamMeta');
        const teamSwitchBar = document.getElementById('teamSwitchBar');
        const raidCooldownMsg = document.getElementById('raidCooldownMsg');
        const raidCapturePanel = document.getElementById('raidCapturePanel');
        const raidCaptureButtons = document.getElementById('raidCaptureButtons');
        const raidCaptureIntro = document.getElementById('raidCaptureIntro');
        const raidCaptureResult = document.getElementById('raidCaptureResult');
        
        // Legendary & Mythical pools (subset for brevity – extend as needed)
        const LEGENDARIES = [144,145,146,150,243,244,245,249,250,382,383,384,483,484,485,486,488,716,717,718];
        const MYTHICALS = [151,251,385,386,489,490,491,492,493,494,647,648,649];
        
        // Reduced raid capture multipliers (applied over simplified base)
        const RAID_CAPTURE_MOD = 0.5; // 50% of normal catch odds
        
        // Start battle when button is clicked
        startBattleBtn.addEventListener('click', startBattle);
        restartBattleBtn.addEventListener('click', restartBattle);
        openRaidLobbyBtn.addEventListener('click', toggleRaidLobby);
        startRaidBtn.addEventListener('click', startRaid);
        
        // Start a new battle
        async function startBattle() {
            try {
                // Show loader, hide start button
                startBattleBtn.classList.add('hidden');
                loader.classList.remove('hidden');
                
                // Generate random IDs for player and opponent Pokémon
                const playerPokemonId = Math.floor(Math.random() * MAX_POKEMON_ID) + 1;
                let opponentPokemonId;
                do {
                    opponentPokemonId = Math.floor(Math.random() * MAX_POKEMON_ID) + 1;
                } while (opponentPokemonId === playerPokemonId);
                
                // Fetch Pokémon data in parallel
                const [playerData, opponentData] = await Promise.all([
                    fetchPokemonData(playerPokemonId),
                    fetchPokemonData(opponentPokemonId)
                ]);
                
                // Set up player and opponent Pokémon
                playerPokemon = createBattlePokemon(playerData);
                opponentPokemon = createBattlePokemon(opponentData);
                
                // Update UI with Pokémon data (moves will be resolved inside)
                await updatePokemonUI();
                
                // Hide start screen, show battle screen
                startScreen.classList.add('hidden');
                battleScreen.classList.remove('hidden');
                
                // Add initial battle message
                addBattleMessage(`A wild ${capitalizeFirstLetter(opponentPokemon.name)} appeared!`);
                addBattleMessage(`Go, ${capitalizeFirstLetter(playerPokemon.name)}!`);
                addBattleMessage(`What will ${capitalizeFirstLetter(playerPokemon.name)} do?`);
                
            } catch (error) {
                console.error('Error starting battle:', error);
                addBattleMessage('Error starting battle. Please try again.');
                loader.classList.add('hidden');
                startBattleBtn.classList.remove('hidden');
            }
        }
        
        // Restart the battle
        function restartBattle() {
            // Reset UI
            battleLog.innerHTML = '';
            moveButtons.innerHTML = '';
            restartBattleBtn.classList.add('hidden');
            
            // Show start screen, hide battle screen
            battleScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            startBattleBtn.classList.remove('hidden');
            
            // Reset battle state
            playerPokemon = null;
            opponentPokemon = null;
            currentTurn = 'player';
            battleEnded = false;
        }
        
        // Fetch Pokémon data from the API
        async function fetchPokemonData(id) {
            const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
            return await response.json();
        }
        
        // Create a battle-ready Pokémon object from API data
        function createBattlePokemon(data) {
            // Calculate HP based on base stat
            const baseHP = data.stats.find(stat => stat.stat.name === 'hp').base_stat;
            const maxHP = Math.floor(baseHP * 2); // Simplified HP calculation
            
            // Get random moves (up to 4)
            const allMoves = data.moves.map(moveData => moveData.move);
            const selectedMoves = getRandomItems(allMoves, Math.min(MAX_MOVES, allMoves.length));
            
            // Fetch move details for each selected move
            const movePromises = selectedMoves.map(move => fetchMoveData(move.url));
            
            return {
                id: data.id,
                name: data.name,
                types: data.types.map(typeData => typeData.type.name),
                maxHP: maxHP,
                currentHP: maxHP,
                moves: movePromises,
                sprite: data.sprites.front_default,
                attack: data.stats.find(stat => stat.stat.name === 'attack').base_stat,
                defense: data.stats.find(stat => stat.stat.name === 'defense').base_stat,
                specialAttack: data.stats.find(stat => stat.stat.name === 'special-attack').base_stat,
                specialDefense: data.stats.find(stat => stat.stat.name === 'special-defense').base_stat,
                speed: data.stats.find(stat => stat.stat.name === 'speed').base_stat
            };
        }
        
        // Fetch move data from the API
        async function fetchMoveData(url) {
            const response = await fetch(url);
            const data = await response.json();
            
            return {
                id: data.id,
                name: data.name,
                type: data.type.name,
                power: data.power || 40, // Default power if not specified
                accuracy: data.accuracy || 100, // Default accuracy if not specified
                damageClass: data.damage_class?.name || 'physical',
                pp: data.pp || 10
            };
        }
        
        // Update UI with Pokémon data
        async function updatePokemonUI() {
            // Update player Pokémon UI
            playerName.textContent = capitalizeFirstLetter(playerPokemon.name);
            playerImage.src = playerPokemon.sprite;
            playerImage.alt = playerPokemon.name;
            playerCurrentHP.textContent = playerPokemon.currentHP;
            playerMaxHP.textContent = playerPokemon.maxHP;
            playerHPFill.style.width = `${(playerPokemon.currentHP / playerPokemon.maxHP) * 100}%`;
            
            // Update player types
            playerTypes.innerHTML = '';
            playerPokemon.types.forEach(type => {
                const typeElement = document.createElement('span');
                typeElement.classList.add('type-badge', type);
                typeElement.textContent = type;
                playerTypes.appendChild(typeElement);
            });
            
            // Update opponent Pokémon UI
            opponentName.textContent = capitalizeFirstLetter(opponentPokemon.name);
            opponentImage.src = opponentPokemon.sprite;
            opponentImage.alt = opponentPokemon.name;
            opponentCurrentHP.textContent = opponentPokemon.currentHP;
            opponentMaxHP.textContent = opponentPokemon.maxHP;
            opponentHPFill.style.width = `${(opponentPokemon.currentHP / opponentPokemon.maxHP) * 100}%`;
            
            // Update opponent types
            opponentTypes.innerHTML = '';
            opponentPokemon.types.forEach(type => {
                const typeElement = document.createElement('span');
                typeElement.classList.add('type-badge', type);
                typeElement.textContent = type;
                opponentTypes.appendChild(typeElement);
            });
            
            // Resolve move promises
            playerPokemon.moves = await Promise.all(playerPokemon.moves);
            opponentPokemon.moves = await Promise.all(opponentPokemon.moves);
            
            // Create move buttons after moves are resolved
            createMoveButtons();
        }
        
        // Create move buttons for player Pokémon
        function createMoveButtons() {
            moveButtons.innerHTML = '';
            
            // Create a button for each move
            playerPokemon.moves.forEach((move, index) => {
                const button = document.createElement('button');
                button.classList.add('move-btn', move.type);
                button.textContent = `${capitalizeFirstLetter(move.name)} (${move.power || '—'})`;
                button.dataset.moveIndex = index;
                button.addEventListener('click', () => useMove(index));
                moveButtons.appendChild(button);
            });
        }
        
        // Use a move
        async function useMove(moveIndex) {
            if (battleEnded) return;

            disableMoveButtons(true);

            if (currentTurn === 'player') {
                const move = playerPokemon.moves[moveIndex];
                addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} used ${capitalizeFirstLetter(move.name)}!`, 'player-text');

                // Check for "protect" move
                if (move.name.toLowerCase().includes('protect')) {
                    playerProtected = true;
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} is protected this turn!`);
                }
                // Check for stat-altering moves
                else if (isStatMove(move.name)) {
                    applyStatMove(playerPokemon, move, 'player');
                }
                // Damage-dealing moves
                else if (move.power && move.power > 0) {
                    const damage = calculateDamage(playerPokemon, opponentPokemon, move);
                    await applyDamage(opponentPokemon, damage, opponentCurrentHP, opponentHPFill);
                    playerProtected = false;
                } else {
                    addBattleMessage(`But nothing happened!`);
                    playerProtected = false;
                }

                if (opponentPokemon.currentHP <= 0) {
                    addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} fainted!`);
                    endBattle(true);
                    return;
                }

                currentTurn = 'opponent';
                setTimeout(opponentTurn, 1500);
            }
        }
        
        // Opponent's turn
        async function opponentTurn() {
            if (battleEnded) return;
            
            const moveIndex = Math.floor(Math.random() * opponentPokemon.moves.length);
            const move = opponentPokemon.moves[moveIndex];

            addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} used ${capitalizeFirstLetter(move.name)}!`, 'opponent-text');

            if (move.name.toLowerCase().includes('protect')) {
                opponentProtected = true;
                addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} is protected this turn!`);
            }
            else if (isStatMove(move.name)) {
                applyStatMove(opponentPokemon, move, 'opponent');
            }
            else if (move.power && move.power > 0) {
                if (playerProtected) {
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} protected itself! No damage taken.`);
                    playerProtected = false;
                } else {
                    const damage = calculateDamage(opponentPokemon, playerPokemon, move);
                    await applyDamage(playerPokemon, damage, playerCurrentHP, playerHPFill);
                }
                opponentProtected = false;
            } else {
                addBattleMessage(`But nothing happened!`);
                opponentProtected = false;
            }

            if (playerPokemon.currentHP <= 0) {
                addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} fainted!`);
                endBattle(false);
                return;
            }

            currentTurn = 'player';
            disableMoveButtons(false);
            addBattleMessage(`What will ${capitalizeFirstLetter(playerPokemon.name)} do?`);
        }
        
        // Detect stat-altering moves by name (add more as needed)
        function isStatMove(moveName) {
            const statMoves = [
                'calm mind', 'swords dance', 'growl', 'leer', 'tail whip', 'harden', 'agility', 'iron defense',
                'bulk up', 'double team', 'amnesia', 'minimize', 'defense curl', 'focus energy', 'howl', 'work up'
            ];
            return statMoves.some(statMove => moveName.toLowerCase().includes(statMove));
        }
        
        // Apply stat changes for stat-altering moves
        function applyStatMove(pokemon, move, side) {
            const name = capitalizeFirstLetter(pokemon.name);
            const moveName = move.name.toLowerCase();

            if (moveName.includes('calm mind')) {
                pokemon.specialAttack = Math.floor(pokemon.specialAttack * 1.5);
                pokemon.specialDefense = Math.floor(pokemon.specialDefense * 1.5);
                addBattleMessage(`${name}'s Special Attack and Special Defense rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('swords dance')) {
                pokemon.attack = Math.floor(pokemon.attack * 2);
                addBattleMessage(`${name}'s Attack sharply rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('growl')) {
                if (side === 'player') {
                    opponentPokemon.attack = Math.max(1, Math.floor(opponentPokemon.attack * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)}'s Attack fell!`, 'opponent-text');
                } else {
                    playerPokemon.attack = Math.max(1, Math.floor(playerPokemon.attack * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)}'s Attack fell!`, 'player-text');
                }
            } else if (moveName.includes('leer') || moveName.includes('tail whip')) {
                if (side === 'player') {
                    opponentPokemon.defense = Math.max(1, Math.floor(opponentPokemon.defense * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)}'s Defense fell!`, 'opponent-text');
                } else {
                    playerPokemon.defense = Math.max(1, Math.floor(playerPokemon.defense * 0.67));
                    addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)}'s Defense fell!`, 'player-text');
                }
            } else if (moveName.includes('harden') || moveName.includes('iron defense') || moveName.includes('defense curl')) {
                pokemon.defense = Math.floor(pokemon.defense * 1.5);
                addBattleMessage(`${name}'s Defense rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('agility') || moveName.includes('double team')) {
                pokemon.speed = Math.floor(pokemon.speed * 1.5);
                addBattleMessage(`${name}'s Speed rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('amnesia')) {
                pokemon.specialDefense = Math.floor(pokemon.specialDefense * 2);
                addBattleMessage(`${name}'s Special Defense sharply rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('focus energy') || moveName.includes('howl') || moveName.includes('work up')) {
                pokemon.attack = Math.floor(pokemon.attack * 1.5);
                addBattleMessage(`${name}'s Attack rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else if (moveName.includes('minimize')) {
                pokemon.speed = Math.floor(pokemon.speed * 2);
                addBattleMessage(`${name}'s evasiveness rose!`, side === 'player' ? 'player-text' : 'opponent-text');
            } else {
                addBattleMessage(`But nothing happened!`, side === 'player' ? 'player-text' : 'opponent-text');
            }
        }
        
        // Calculate damage
        function calculateDamage(attacker, defender, move) {
            // Skip calculation if move has no power
            if (!move.power) return 0;

            // Use fixed level for both Pokémon
            const level = 50;

            // Choose attack/defense stats based on move class
            let attack = move.damageClass === 'special' ? attacker.specialAttack : attacker.attack;
            let defense = move.damageClass === 'special' ? defender.specialDefense : defender.defense;

            // STAB (Same Type Attack Bonus)
            let stab = attacker.types.includes(move.type) ? 1.5 : 1.0;

            // Type effectiveness
            const effectiveness = getTypeEffectiveness(move.type, defender.types);

            // Random factor between 0.85 and 1.00
            const random = (Math.random() * 0.15) + 0.85;

            // Accuracy check
            if (move.accuracy && Math.random() * 100 > move.accuracy) {
                addBattleMessage('But it missed!');
                return 0;
            }

            // Damage formula (classic Pokémon)
            let baseDamage = (((2 * level / 5 + 2) * move.power * attack / defense) / 50) + 2;
            let modifier = stab * effectiveness * random;
            let damage = Math.floor(baseDamage * modifier);

            // Critical hit (10% chance)
            if (Math.random() < 0.1) {
                damage = Math.floor(damage * 1.5);
                addBattleMessage('A critical hit!');
            }

            // Type effectiveness messages
            if (effectiveness > 1) {
                addBattleMessage('It\'s super effective!');
            } else if (effectiveness < 1 && effectiveness > 0) {
                addBattleMessage('It\'s not very effective...');
            } else if (effectiveness === 0) {
                addBattleMessage('It has no effect...');
                return 0;
            }

            // Ensure minimum damage is 1 if move hit and effectiveness > 0
            return Math.max(1, damage);
        }
        
        // Apply damage to a Pokémon
        async function applyDamage(pokemon, damage, hpElement, hpFillElement) {
            pokemon.currentHP = Math.max(0, pokemon.currentHP - damage);
            hpElement.textContent = pokemon.currentHP;
            hpFillElement.style.width = `${(pokemon.currentHP / pokemon.maxHP) * 100}%`;
            
            // Update HP bar color based on remaining HP percentage
            const hpPercentage = pokemon.currentHP / pokemon.maxHP;
            if (hpPercentage <= 0.2) {
                hpFillElement.style.backgroundColor = '#ff0000'; // Red
            } else if (hpPercentage <= 0.5) {
                hpFillElement.style.backgroundColor = '#ffff00'; // Yellow
            } else {
                hpFillElement.style.backgroundColor = '#4CAF50'; // Green
            }
            
            return new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // End the battle
        function endBattle(playerWon) {
            battleEnded = true;
            
            if (playerWon) {
                addBattleMessage(`${capitalizeFirstLetter(playerPokemon.name)} won the battle!`);
            } else {
                addBattleMessage(`${capitalizeFirstLetter(opponentPokemon.name)} won the battle!`);
            }
            
            // Show restart button
            restartBattleBtn.classList.remove('hidden');
        }
        
        // Add a message to the battle log
        function addBattleMessage(message, className) {
            const messageElement = document.createElement('p');
            messageElement.textContent = message;
            if (className) {
                messageElement.classList.add(className);
            }
            battleLog.appendChild(messageElement);
            battleLog.scrollTop = battleLog.scrollHeight;
        }
        
        // Enable/disable move buttons
        function disableMoveButtons(disabled) {
            const buttons = moveButtons.querySelectorAll('button');
            buttons.forEach(button => {
                button.disabled = disabled;
            });
        }
        
        // Get random items from an array
        function getRandomItems(array, count) {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }
        
        // Capitalize the first letter of a string
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.replace('-', ' ').slice(1);
        }
        
        // Get type effectiveness (simplified version)
        function getTypeEffectiveness(moveType, defenderTypes) {
            // Simplified type chart for demo purposes
            const typeChart = {
                normal: { rock: 0.5, ghost: 0, steel: 0.5 },
                fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
                water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 },
                electric: { water: 2, electric: 0.5, grass: 0.5, ground: 0, flying: 2, dragon: 0.5 },
                grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },
                ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
                fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2, fairy: 0.5 },
                poison: { grass: 2, poison: 0.5, ground: 0.5, rock: 0.5, ghost: 0.5, steel: 0, fairy: 2 },
                ground: { fire: 2, electric: 2, grass: 0.5, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 },
                flying: { electric: 0.5, grass: 2, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
                psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 },
                bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5, fairy: 0.5 },
                rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 },
                ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5 },
                dragon: { dragon: 2, steel: 0.5, fairy: 0 },
                dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5 },
                steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5, fairy: 2 },
                fairy: { fighting: 2, poison: 0.5, bug: 0.5, dragon: 2, dark: 2, steel: 0.5 }
            };
            
            let effectiveness = 1;
            
            defenderTypes.forEach(defenderType => {
                if (typeChart[moveType] && typeChart[moveType][defenderType] !== undefined) {
                    effectiveness *= typeChart[moveType][defenderType];
                }
            });
            
            return effectiveness;
        }
        
        /* Raid functions */
        function toggleRaidLobby(){
            if(!checkRaidCooldownUI()) return;
            raidLobby.classList.toggle('hidden');
            if(!raidLobby.classList.contains('hidden')) {
                loadOwnedPokemonForRaid();
            }
        }
        
        async function loadSavedRaidTeamIds(){
            try{
                const r = await fetch('/api/raid-team');
                if(!r.ok) return [];
                const d = await r.json();
                return Array.isArray(d.team) ? d.team : [];
            }catch{ return []; }
        }
        async function saveRaidTeamIds(ids){
            try{
                await fetch('/api/raid-team',{
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({ team:ids })
                });
            }catch{}
        }
        
        async function loadOwnedPokemonForRaid() {
            teamSelectGrid.innerHTML = 'Loading...';
            try {
                const savedIds = await loadSavedRaidTeamIds(); // NEW
                const res = await fetch('/api/get-pokemon');
                const data = await res.json();
                teamSelectGrid.innerHTML = '';
                const selectedIds = new Set(savedIds.slice(0,3)); // pre-select (max 3)
                data.forEach(p => {
                    const card = document.createElement('div');
                    card.className = 'team-card';
                    const id = p.pokemonId || p.id;
                    const name = p.pokemonName || p.name;
                    const img = p.pokemonImage || p.image || `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
                    card.innerHTML = `<img src="${img}" alt="${name}"><div style="font-size:12px;text-align:center">${capitalizeFirstLetter(name)}<br>#${String(id).padStart(3,'0')}</div>`;
                    if (selectedIds.has(id)) card.classList.add('selected'); // NEW
                    card.addEventListener('click', () => {
                        if (card.classList.contains('selected')) {
                            card.classList.remove('selected');
                            selectedIds.delete(id);
                        } else {
                            if (selectedIds.size >= 3) return;
                            card.classList.add('selected');
                            selectedIds.add(id);
                        }
                        updateRaidTeamMeta(selectedIds);
                    });
                    teamSelectGrid.appendChild(card);
                });
                updateRaidTeamMeta(selectedIds); // NEW ensure button state
            } catch (e) {
                teamSelectGrid.innerHTML = 'Failed to load Pokémon.';
            }
        }
        
        function updateRaidTeamMeta(selectedIds){
            raidTeamMeta.textContent = `Selected: ${[...selectedIds].join(', ') || 'None'}`;
            startRaidBtn.disabled = selectedIds.size === 0;
        }
        
        function checkRaidCooldownUI() {
            const now = Date.now();
            const stored = localStorage.getItem('raidCooldownUntil');
            if (stored) {
                const ts = parseInt(stored,10);
                if (ts > now) {
                    const mins = Math.ceil((ts - now)/60000);
                    raidCooldownMsg.textContent = `Raid on cooldown. Try again in ~${mins} min.`;
                    raidCooldownMsg.classList.remove('hidden');
                    return false;
                }
            }
            raidCooldownMsg.classList.add('hidden');
            return true;
        }
        
        function setRaidCooldown() {
            const until = Date.now() + RAID_COOLDOWN_MINUTES * 60000;
            localStorage.setItem('raidCooldownUntil', until);
        }
        
        async function startRaid(){
            if (!checkRaidCooldownUI()) return;
            const selected = [...teamSelectGrid.querySelectorAll('.team-card.selected')];
            if (!selected.length) return;
            const pickedIds = [];
            raidTeam = [];
            for (const card of selected) {
                const idText = card.querySelector('div').textContent.match(/#(\d+)/);
                if (!idText) continue;
                const id = parseInt(idText[1],10);
                pickedIds.push(id);                 // NEW
                const raw = await fetchPokemonData(id);
                raidTeam.push(createBattlePokemon(raw));
            }
            await saveRaidTeamIds(pickedIds);       // NEW persist team
            // Determine raid boss (legendary or mythical)
            const pool = Math.random() < 0.5 ? LEGENDARIES : MYTHICALS;
            const bossId = pool[Math.floor(Math.random()*pool.length)];
            isRaid = true;
            raidCapturePhase = false;
            await prepareRaidBoss(bossId);
            raidLobby.classList.add('hidden');
            startBattleCore(true); // start using raid data
        }
        
        async function prepareRaidBoss(id){
            const data = await fetchPokemonData(id);
            opponentPokemon = createBattlePokemon(data);
            raidBossOriginal = opponentPokemon.name;
            // Boost boss stats for challenge
            opponentPokemon.maxHP = Math.floor(opponentPokemon.maxHP * 1.3);
            opponentPokemon.currentHP = opponentPokemon.maxHP;
            opponentPokemon.defense = Math.floor(opponentPokemon.defense * 1.15);
            opponentPokemon.specialDefense = Math.floor(opponentPokemon.specialDefense * 1.15);
        }
        
        function startBattleCore(raidMode=false){
            // For raid: playerPokemon = active member of raidTeam
            if (raidMode && raidTeam.length){
                activePlayerIndex = 0;
                playerPokemon = raidTeam[activePlayerIndex];
            }
            // Reuse existing update flow
            startScreen.classList.add('hidden');
            battleScreen.classList.remove('hidden');
            loader.classList.add('hidden');
            buildTeamSwitchBar();
            updatePokemonUI().then(()=>{
                if (isRaid){
                    addBattleMessage(`A Raid Boss ${capitalizeFirstLetter(opponentPokemon.name)} appeared!`, 'opponent-text');
                    addBattleMessage(`Send out ${capitalizeFirstLetter(playerPokemon.name)}!`, 'player-text');
                }
            });
        }
        
        function buildTeamSwitchBar(){
            if (!isRaid) return;
            if (!teamSwitchBar) return; // NEW null guard
            teamSwitchBar.innerHTML = '';
            teamSwitchBar.classList.remove('hidden');
            raidTeam.forEach((p, idx)=>{
                const btn = document.createElement('button');
                btn.className='team-switch-btn';
                btn.textContent = capitalizeFirstLetter(p.name);
                btn.disabled = (idx === activePlayerIndex) || p.currentHP<=0;
                if (idx === activePlayerIndex) btn.classList.add('active');
                btn.addEventListener('click', ()=> switchActivePokemon(idx));
                teamSwitchBar.appendChild(btn);
            });
        }
        
        async function ensureMovesLoaded(pokemon){ // NEW
            if (!pokemon) return;
            if (Array.isArray(pokemon.moves) && pokemon.moves.length && typeof pokemon.moves[0].then === 'function'){
                pokemon.moves = await Promise.all(pokemon.moves);
            }
        }
        
        function switchActivePokemon(newIndex){
            if (battleEnded || raidCapturePhase) return;
            if (newIndex === activePlayerIndex) return;
            if (raidTeam[newIndex].currentHP<=0) return;
            activePlayerIndex = newIndex;
            playerPokemon = raidTeam[activePlayerIndex];
            ensureMovesLoaded(playerPokemon).then(()=>{
                createMoveButtons(); // NEW regenerate buttons for new mon
                addBattleMessage(`You switched to ${capitalizeFirstLetter(playerPokemon.name)}!`, 'player-text');
                updatePokemonUI();
                disableMoveButtons(false);
                buildTeamSwitchBar();
            });
        }
        
        // Override faint handling in existing flow: hook into applyDamage aftermath via checks where faint is processed
        const originalEndBattle = endBattle;
        endBattle = function(playerWon){
            if (isRaid && playerWon){
                // Instead of immediate end -> capture phase
                raidCapturePhase = true;
                disableMoveButtons(true);
                addBattleMessage('Raid Boss defeated! Capture opportunity begins.', 'player-text');
                showRaidCaptureUI();
                setRaidCooldown();
                return;
            }
            originalEndBattle(playerWon);
            if (isRaid && !playerWon) setRaidCooldown();
        };
        
        // Inject check after opponent damages player (loss condition across team)
        const originalOpponentTurn = opponentTurn;
        opponentTurn = async function(){
            await originalOpponentTurn();
            if (isRaid && !battleEnded && playerPokemon?.currentHP===0){
                // Try auto-switch
                const nextIdx = raidTeam.findIndex(p=>p.currentHP>0);
                if (nextIdx===-1){
                    addBattleMessage('All your team fainted!', 'opponent-text');
                    originalEndBattle(false);
                    setRaidCooldown();
                } else {
                    activePlayerIndex = nextIdx;
                    playerPokemon = raidTeam[activePlayerIndex];
                    await ensureMovesLoaded(playerPokemon); // NEW
                    createMoveButtons();                    // NEW
                    buildTeamSwitchBar();
                    addBattleMessage(`Go, ${capitalizeFirstLetter(playerPokemon.name)}!`, 'player-text');
                    updatePokemonUI();
                }
            }
            buildTeamSwitchBar();
        };
        
        // Replace startBattle entry for random (kept) to call startBattleCore(false). We minimally wrap original startBattle.
        const originalStartBattle = startBattle;
        startBattle = async function(){
            isRaid = false;
            raidTeam = [];
            await originalStartBattle();
        };
        
        // --- Raid Capture Phase ---
        async function showRaidCaptureUI(){
            raidCapturePanel.classList.remove('hidden');
            raidCaptureIntro.textContent = `You have a limited chance to capture ${capitalizeFirstLetter(raidBossOriginal)}. Choose a Poké Ball:`;
            raidCaptureButtons.innerHTML='Loading balls...';
            try {
                const res = await fetch('/api/pokeballs');
                const data = await res.json();
                const inventory = {};
                (data.pokeballs||[]).forEach(b=>inventory[b.type]=b.count);
                const ballTypes = ['pokeball','greatball','ultraball','masterball'];
                raidCaptureButtons.innerHTML='';
                ballTypes.forEach(bt=>{
                    const count = inventory[bt]||0;
                    const btn = document.createElement('button');
                    btn.textContent = `${formatBall(bt)} (${count})`;
                    btn.disabled = count<=0;
                    btn.addEventListener('click', ()=>attemptRaidCapture(bt,count));
                    raidCaptureButtons.appendChild(btn);
                });
            } catch (e){
                raidCaptureButtons.innerHTML='Failed to load inventory.';
            }
        }
        
        function formatBall(bt){
            switch(bt){
                case 'pokeball': return 'Poké Ball';
                case 'greatball': return 'Great Ball';
                case 'ultraball': return 'Ultra Ball';
                case 'masterball': return 'Master Ball';
                default: return bt;
            }
        }
        
        async function attemptRaidCapture(ballType,currentCount){
            // Decrement immediately (optimistic)
            await fetch('/api/pokeballs-update', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify({type:ballType,count:currentCount-1})
            }).catch(()=>{});
            
            const base = { pokeball:0.08, greatball:0.15, ultraball:0.25, masterball:1.0 }[ballType] || 0.05;
            const chance = Math.min(1, base * RAID_CAPTURE_MOD);
            const roll = Math.random();
            const success = roll < chance || ballType==='masterball';
            raidCaptureResult.textContent = `Roll ${(roll*100).toFixed(1)}% vs ${(chance*100).toFixed(1)}% => ${success? 'Captured!':'Broke free!'}`;
            if (success){
                await saveRaidCapture(opponentPokemon);
                await postRaidResult(true,true);
                addBattleMessage(`You captured ${capitalizeFirstLetter(opponentPokemon.name)}!`, 'player-text');
                finalizeRaid();
            } else {
                await postRaidResult(true,false);
                finalizeRaid();
            }
        }
        
        function finalizeRaid(){
            raidCaptureButtons.querySelectorAll('button').forEach(b=>b.disabled=true);
            restartBattleBtn.classList.remove('hidden');
            battleEnded = true;
        }
        
        async function saveRaidCapture(poke){
            try {
                await fetch('/api/save-pokemon', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({
                        pokemonName: poke.name,
                        pokemonImage: poke.sprite,
                        pokemonId: poke.id,
                        pokemonTypes: poke.types,
                        rarity: MYTHICALS.includes(poke.id)?'mythical':'legendary'
                    })
                });
            } catch(e){}
        }
        
        async function postRaidResult(defeated,captured){
            try {
                await fetch('/api/raid-result', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({
                        bossId: opponentPokemon.id,
                        defeated,
                        captured,
                        timestamp: Date.now()
                    })
                });
            } catch(e){}
        }
        
        // Utility reuse of capitalizeFirstLetter already exists in file
        // End of raid additions
    </script>
</body>
</html>